#!/usr/bin/env python3
import argparse
import base64
import json
import hmac
import hashlib
import os

def base64_decode(data):
    missing_padding = len(data) % 4
    if missing_padding:
        data += '=' * (4 - missing_padding)
    return base64.b64decode(data).decode('utf-8')

def base64url_encode(data):
    if isinstance(data, str):
        data = data.encode()
    return base64.urlsafe_b64encode(data).decode('utf-8').rstrip('=')

def main():
    parser = argparse.ArgumentParser(description="JWT Multi-Tool")
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("--decode", "-d", action="store_true")
    group.add_argument("--encode", "-e", action="store_true")

    parser.add_argument("-t", "--token", help="The JWT string to decode")
    parser.add_argument("-p", "--payload", help="JSON string for the payload")
    parser.add_argument("-s", "--secret", default="", help="Secret key OR path to file")
    parser.add_argument("-a", "--alg", default="HS256", help="Algorithm")

    args = parser.parse_args()

    # --- SECRET HANDLING ---
    # We use .strip() for files to avoid accidental terminal newlines
    if args.secret and os.path.isfile(args.secret):
        with open(args.secret, 'rb') as f:
            secret_bytes = f.read().strip()
    else:
        # If passed as a string, use it exactly as provided
        secret_bytes = args.secret.encode()

    if args.decode:
        if not args.token:
            print("[-] Error: --token is required.")
            return
        try:
            segments = args.token.split('.')
            header = json.loads(base64_decode(segments[0]))
            payload = json.loads(base64_decode(segments[1]))
            print("\n=== DECODED COMPONENTS ===")
            print(f"Header:  {json.dumps(header, indent=4)}")
            print(f"Payload: {json.dumps(payload, indent=4)}")
            print("==========================\n")
        except Exception as e:
            print(f"[-] Decode failed: {e}")

    elif args.encode:
        if not args.payload:
            print("[-] Error: --payload is required.")
            return

        try:
            # 1. FIXED HEADER ORDER (Matches your working token)
            # Working token uses: {"alg":"HS256","typ":"JWT"}
            if args.alg.lower() == "none":
                header_json = '{"alg":"none","typ":"JWT"}'
            else:
                header_json = '{"alg":"HS256","typ":"JWT"}'
            
            header_b64 = base64url_encode(header_json)

            # 2. PAYLOAD (Minified)
            payload_data = json.loads(args.payload)
            payload_json = json.dumps(payload_data, separators=(',', ':'))
            payload_b64 = base64url_encode(payload_json)

            # 3. SIGNING
            signing_input = f"{header_b64}.{payload_b64}"

            if args.alg.lower() == "none":
                signature_b64 = ""
            else:
                signature = hmac.new(
                    secret_bytes, 
                    signing_input.encode(), 
                    hashlib.sha256
                ).digest()
                signature_b64 = base64url_encode(signature)

            print("\n=== GENERATED TOKEN ===")
            print(f"{signing_input}.{signature_b64}")
            print("=======================\n")

        except Exception as e:
            print(f"[-] Encode failed: {e}")

if __name__ == "__main__":
    main()
